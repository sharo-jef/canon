import * as fs from 'fs';
import * as yaml from 'js-yaml';
import { CharStreams, CommonTokenStream } from 'antlr4ts';
import { AbstractParseTreeVisitor } from 'antlr4ts/tree/AbstractParseTreeVisitor';
import { RuleNode } from 'antlr4ts/tree/RuleNode';
import { CanonLexer } from './generated/CanonLexer';
import {
  CanonParser,
  ProgramContext,
  SchemaDirectiveContext,
  UseStatementContext,
  TopLevelElementContext,
  SchemaDeclarationContext,
  StructDeclarationContext,
  UnionDeclarationContext,
  TypeDeclarationContext,
  TypeContext,
  BaseTypeContext,
  PrimitiveTypeContext,
  BlockContext,
  BlockContentContext,
  PropertyDeclarationContext,
  AssignmentStatementContext,
  InitDeclarationContext,
  FunctionDeclarationContext,
  GetterDeclarationContext,
  RepeatedDeclarationContext,
  MappingBlockContext,
  MappingEntryContext,
  ParameterListContext,
  ParameterContext,
  CallExpressionContext,
  ArgumentListContext,
  ExpressionStatementContext,
  LiteralContext,
  StringLiteralContext,
  TemplateStringContext,
  TemplateStringContentContext,
  AnnotationContext,
  PrimaryExpressionContext,
  MemberAccessExpressionContext,
  FunctionCallExpressionContext,
  UnaryMinusExpressionContext,
  LogicalNotExpressionContext,
  MultiplicativeExpressionContext,
  AdditiveExpressionContext,
  RelationalExpressionContext,
  EqualityExpressionContext,
  LogicalAndExpressionContext,
  LogicalOrExpressionContext,
  LiteralExpressionContext,
  IdentifierExpressionContext,
  ThisExpressionContext,
  IfExpressionContext,
  ParenthesizedExpressionContext,
  CallExpressionPrimaryContext,
} from './generated/CanonParser';
import { CanonParserVisitor } from './generated/CanonParserVisitor';

export interface ASTLocation {
  start: { line: number; column: number };
  end: { line: number; column: number };
}

export interface ASTNode {
  type: string;
  [key: string]: any;
}

/**
 * AST Builder that converts ANTLR parse tree to AST using visitor pattern.
 *
 * This class implements the visitor pattern to traverse the Concrete Syntax Tree (CST)
 * generated by ANTLR and converts it into a more usable Abstract Syntax Tree (AST).
 *
 * Key responsibilities:
 * - Transform context objects into standardized AST nodes
 * - Extract location information for error reporting
 * - Handle null safety for optional grammar elements
 * - Apply semantic transformations (e.g., unquoting strings)
 * - Maintain structural integrity of the Canon language semantics
 */
class ASTBuilder extends AbstractParseTreeVisitor<ASTNode> implements CanonParserVisitor<ASTNode> {
  defaultResult(): ASTNode {
    return { type: 'Unknown' };
  }

  /**
   * Extracts location information from ANTLR context nodes.
   * @param node - ANTLR context node
   * @returns Location information or undefined if extraction fails
   */
  private getLocationInfo(node: any): ASTLocation | undefined {
    try {
      if (node && node.start && node.stop) {
        return {
          start: {
            line: node.start.line,
            column: node.start.charPositionInLine,
          },
          end: {
            line: node.stop.line,
            column: node.stop.charPositionInLine + (node.stop.text?.length || 0),
          },
        };
      }
    } catch {
      // If location extraction fails, return undefined
    }
    return undefined;
  }

  /**
   * Removes surrounding quotes from string literals.
   * Handles both single and double quoted strings.
   * @param text - Quoted string text
   * @returns Unquoted string content
   */
  private unquote(text: string): string {
    if (
      (text.startsWith("'") && text.endsWith("'")) ||
      (text.startsWith('"') && text.endsWith('"'))
    ) {
      return text.slice(1, -1);
    }
    return text;
  }

  visitProgram(ctx: ProgramContext): ASTNode {
    const children: ASTNode[] = [];

    for (let i = 0; i < ctx.childCount; i++) {
      const child = ctx.getChild(i);
      if (child instanceof RuleNode) {
        const result = this.visit(child);
        if (result && result.type !== 'Unknown') {
          children.push(result);
        }
      }
    }

    return {
      type: 'Program',
      body: children,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitSchemaDirective(ctx: SchemaDirectiveContext): ASTNode {
    const pathNode = this.visit(ctx.stringLiteral());
    return {
      type: 'SchemaDirective',
      path: pathNode.value,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitUseStatement(ctx: UseStatementContext): ASTNode {
    const identifierToken = ctx.IDENTIFIER();
    return {
      type: 'UseStatement',
      identifier: {
        type: 'Identifier',
        name: identifierToken.text,
        loc: {
          start: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine,
          },
          end: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
          },
        },
      },
      loc: this.getLocationInfo(ctx),
    };
  }

  visitTopLevelElement(ctx: TopLevelElementContext): ASTNode {
    // TopLevelElement is a choice rule, so we visit the actual content
    for (let i = 0; i < ctx.childCount; i++) {
      const child = ctx.getChild(i);
      if (child instanceof RuleNode) {
        return this.visit(child);
      }
    }
    return this.defaultResult();
  }

  visitSchemaDeclaration(ctx: SchemaDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const body = this.visit(ctx.block());

    return {
      type: 'SchemaDeclaration',
      annotations,
      body: body.content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitStructDeclaration(ctx: StructDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const body = this.visit(ctx.block());

    return {
      type: 'StructDeclaration',
      name,
      annotations,
      body: body.content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitUnionDeclaration(ctx: UnionDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const types = ctx
      .unionType()
      .type()
      .map((t) => this.visit(t));

    return {
      type: 'UnionDeclaration',
      name,
      annotations,
      types,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitTypeDeclaration(ctx: TypeDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const typeRef = this.visit(ctx.type());

    return {
      type: 'TypeDeclaration',
      name,
      annotations,
      typeRef,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitType(ctx: TypeContext): ASTNode {
    const baseType = this.visit(ctx.baseType());
    const arrayDimensions = ctx.LBRACKET().length;

    if (arrayDimensions > 0) {
      return {
        type: 'ArrayType',
        elementType: baseType,
        dimensions: arrayDimensions,
        loc: this.getLocationInfo(ctx),
      };
    }

    return baseType;
  }

  visitBaseType(ctx: BaseTypeContext): ASTNode {
    if (ctx.primitiveType()) {
      return this.visit(ctx.primitiveType()!);
    } else {
      const identifierToken = ctx.IDENTIFIER()!;
      return {
        type: 'TypeReference',
        name: {
          type: 'Identifier',
          name: identifierToken.text,
          loc: {
            start: {
              line: identifierToken.symbol.line,
              column: identifierToken.symbol.charPositionInLine,
            },
            end: {
              line: identifierToken.symbol.line,
              column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
            },
          },
        },
        loc: this.getLocationInfo(ctx),
      };
    }
  }

  visitPrimitiveType(ctx: PrimitiveTypeContext): ASTNode {
    let typeName: string;
    if (ctx.STRING_TYPE()) {
      typeName = 'string';
    } else if (ctx.INT_TYPE()) {
      typeName = 'int';
    } else if (ctx.BOOL_TYPE()) {
      typeName = 'bool';
    } else {
      typeName = 'unknown';
    }

    return {
      type: 'PrimitiveType',
      name: typeName,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitBlock(ctx: BlockContext): ASTNode {
    const content = ctx.blockContent().map((bc) => this.visit(bc));

    return {
      type: 'Block',
      content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitBlockContent(ctx: BlockContentContext): ASTNode {
    // BlockContent is a choice rule, so we visit the actual content
    for (let i = 0; i < ctx.childCount; i++) {
      const child = ctx.getChild(i);
      if (child instanceof RuleNode) {
        return this.visit(child);
      }
    }
    return this.defaultResult();
  }
  visitPropertyDeclaration(ctx: PropertyDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const isPrivate = ctx.PRIVATE() !== undefined;
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const isOptional = ctx.QUESTION() !== undefined;

    let typeRef: ASTNode | undefined;
    if (ctx.type()) {
      typeRef = this.visit(ctx.type()!);
    } else {
      // 型が省略されている場合、プロパティ名と同じ名前の TypeReference を生成
      typeRef = {
        type: 'TypeReference',
        name: {
          type: 'Identifier',
          name: identifierToken.text,
          loc: {
            start: {
              line: identifierToken.symbol.line,
              column: identifierToken.symbol.charPositionInLine,
            },
            end: {
              line: identifierToken.symbol.line,
              column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
            },
          },
        },
        loc: {
          start: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine,
          },
          end: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
          },
        },
      };
    }

    const defaultValue = ctx.expression() ? this.visit(ctx.expression()!) : undefined;

    return {
      type: 'PropertyDeclaration',
      name,
      annotations,
      isPrivate,
      isOptional,
      typeRef,
      defaultValue,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitAssignmentStatement(ctx: AssignmentStatementContext): ASTNode {
    const value = this.visit(ctx.expression());

    let left: ASTNode;
    if (ctx.THIS()) {
      // this.identifier の場合はMemberAccessExpressionとして表現
      left = {
        type: 'MemberAccessExpression',
        object: {
          type: 'ThisExpression',
          loc: {
            start: {
              line: ctx.THIS()!.symbol.line,
              column: ctx.THIS()!.symbol.charPositionInLine,
            },
            end: {
              line: ctx.THIS()!.symbol.line,
              column: ctx.THIS()!.symbol.charPositionInLine + 4, // "this".length
            },
          },
        },
        property: {
          type: 'Identifier',
          name: ctx.IDENTIFIER().text,
          loc: {
            start: {
              line: ctx.IDENTIFIER().symbol.line,
              column: ctx.IDENTIFIER().symbol.charPositionInLine,
            },
            end: {
              line: ctx.IDENTIFIER().symbol.line,
              column: ctx.IDENTIFIER().symbol.charPositionInLine + ctx.IDENTIFIER().text.length,
            },
          },
        },
        computed: false,
        loc: this.getLocationInfo(ctx),
      };
    } else {
      // identifier の場合はIdentifierとして表現
      left = {
        type: 'Identifier',
        name: ctx.IDENTIFIER().text,
        loc: {
          start: {
            line: ctx.IDENTIFIER().symbol.line,
            column: ctx.IDENTIFIER().symbol.charPositionInLine,
          },
          end: {
            line: ctx.IDENTIFIER().symbol.line,
            column: ctx.IDENTIFIER().symbol.charPositionInLine + ctx.IDENTIFIER().text.length,
          },
        },
      };
    }

    return {
      type: 'AssignmentStatement',
      left,
      right: value,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitInitDeclaration(ctx: InitDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const paramList = ctx.parameterList();
    const parameters = paramList
      ? this.visit(paramList)
      : { type: 'ParameterList', parameters: [] };
    const body = this.visit(ctx.block());

    return {
      type: 'InitDeclaration',
      annotations,
      parameters: parameters.parameters,
      body: body.content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitFunctionDeclaration(ctx: FunctionDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const isPrivate = ctx.PRIVATE() !== undefined;
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const paramList = ctx.parameterList();
    const parameters = paramList
      ? this.visit(paramList)
      : { type: 'ParameterList', parameters: [] };
    const body = this.visit(ctx.block());

    return {
      type: 'FunctionDeclaration',
      name,
      annotations,
      isPrivate,
      parameters: parameters.parameters,
      body: body.content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitGetterDeclaration(ctx: GetterDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const body = this.visit(ctx.block());

    return {
      type: 'GetterDeclaration',
      name,
      annotations,
      body: body.content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitRepeatedDeclaration(ctx: RepeatedDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const typeRef = this.visit(ctx.type());
    const mappingBlock = ctx.mappingBlock();
    const mapping = mappingBlock ? this.visit(mappingBlock) : undefined;
    const expressionCtx = ctx.expression();
    const defaultValue = expressionCtx ? this.visit(expressionCtx) : undefined;

    return {
      type: 'RepeatedDeclaration',
      name,
      annotations,
      typeRef,
      mapping,
      defaultValue,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitMappingBlock(ctx: MappingBlockContext): ASTNode {
    const entries = ctx.mappingEntry().map((entry) => this.visit(entry));

    return {
      type: 'MappingBlock',
      entries,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitMappingEntry(ctx: MappingEntryContext): ASTNode {
    const fromToken = ctx.IDENTIFIER(0);
    const toToken = ctx.IDENTIFIER(1);
    const from = {
      type: 'Identifier',
      name: fromToken.text,
      loc: {
        start: {
          line: fromToken.symbol.line,
          column: fromToken.symbol.charPositionInLine,
        },
        end: {
          line: fromToken.symbol.line,
          column: fromToken.symbol.charPositionInLine + fromToken.text.length,
        },
      },
    };
    const to = {
      type: 'Identifier',
      name: toToken.text,
      loc: {
        start: {
          line: toToken.symbol.line,
          column: toToken.symbol.charPositionInLine,
        },
        end: {
          line: toToken.symbol.line,
          column: toToken.symbol.charPositionInLine + toToken.text.length,
        },
      },
    };

    return {
      type: 'MappingEntry',
      from,
      to,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitParameterList(ctx: ParameterListContext): ASTNode {
    const parameters = ctx.parameter().map((param) => this.visit(param));

    return {
      type: 'ParameterList',
      parameters,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitParameter(ctx: ParameterContext): ASTNode {
    const identifierToken = ctx.IDENTIFIER();

    let name: ASTNode;
    if (ctx.THIS() !== undefined) {
      // this.property のパラメータの場合、MemberAccessExpressionとして扱う
      name = {
        type: 'MemberAccessExpression',
        object: {
          type: 'ThisExpression',
          loc: {
            start: {
              line: ctx.THIS()!.symbol.line,
              column: ctx.THIS()!.symbol.charPositionInLine,
            },
            end: {
              line: ctx.THIS()!.symbol.line,
              column: ctx.THIS()!.symbol.charPositionInLine + 4, // 'this'.length
            },
          },
        },
        property: {
          type: 'Identifier',
          name: identifierToken.text,
          loc: {
            start: {
              line: identifierToken.symbol.line,
              column: identifierToken.symbol.charPositionInLine,
            },
            end: {
              line: identifierToken.symbol.line,
              column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
            },
          },
        },
        computed: false,
        loc: this.getLocationInfo(ctx),
      };
    } else {
      // 通常のパラメータの場合
      name = {
        type: 'Identifier',
        name: identifierToken.text,
        loc: {
          start: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine,
          },
          end: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
          },
        },
      };
    }

    const typeCtx = ctx.type();
    const typeRef = typeCtx ? this.visit(typeCtx) : undefined;

    return {
      type: 'Parameter',
      name,
      typeRef,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitCallExpression(ctx: CallExpressionContext): ASTNode {
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const argList = ctx.argumentList();
    const args = argList ? this.visit(argList) : { type: 'ArgumentList', arguments: [] };
    const block = ctx.block();
    const lambdaBody = block ? this.visit(block) : undefined;

    return {
      type: 'CallExpression',
      name,
      arguments: args.arguments,
      lambdaBody: lambdaBody?.content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitArgumentList(ctx: ArgumentListContext): ASTNode {
    const args = ctx.expression().map((expr) => this.visit(expr));

    return {
      type: 'ArgumentList',
      arguments: args,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitExpressionStatement(ctx: ExpressionStatementContext): ASTNode {
    const expression = this.visit(ctx.expression());
    return {
      type: 'ExpressionStatement',
      expression,
      loc: this.getLocationInfo(ctx),
    };
  }

  // Expression visitors
  visitPrimaryExpression(ctx: PrimaryExpressionContext): ASTNode {
    return this.visit(ctx.primary());
  }

  visitMemberAccessExpression(ctx: MemberAccessExpressionContext): ASTNode {
    const object = this.visit(ctx.expression());
    const property = {
      type: 'Identifier',
      name: ctx.IDENTIFIER().text,
      loc: {
        start: {
          line: ctx.IDENTIFIER().symbol.line,
          column: ctx.IDENTIFIER().symbol.charPositionInLine,
        },
        end: {
          line: ctx.IDENTIFIER().symbol.line,
          column: ctx.IDENTIFIER().symbol.charPositionInLine + ctx.IDENTIFIER().text.length,
        },
      },
    };

    return {
      type: 'MemberAccessExpression',
      object,
      property,
      computed: false, // obj.prop の形式なので computed は false
      loc: this.getLocationInfo(ctx),
    };
  }

  visitFunctionCallExpression(ctx: FunctionCallExpressionContext): ASTNode {
    const callee = this.visit(ctx.expression());
    const argList = ctx.argumentList();
    const args = argList ? this.visit(argList) : { type: 'ArgumentList', arguments: [] };

    return {
      type: 'CallExpression',
      callee,
      arguments: args.arguments,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitUnaryMinusExpression(ctx: UnaryMinusExpressionContext): ASTNode {
    const operand = this.visit(ctx.expression());

    return {
      type: 'UnaryExpression',
      operator: '-',
      operand,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitLogicalNotExpression(ctx: LogicalNotExpressionContext): ASTNode {
    const operand = this.visit(ctx.expression());

    return {
      type: 'UnaryExpression',
      operator: 'not',
      operand,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitMultiplicativeExpression(ctx: MultiplicativeExpressionContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    let operator: string;

    if (ctx.MULTIPLY()) {
      operator = '*';
    } else if (ctx.DIVIDE()) {
      operator = '/';
    } else if (ctx.MODULO()) {
      operator = '%';
    } else {
      operator = 'unknown';
    }

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitAdditiveExpression(ctx: AdditiveExpressionContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    const operator = ctx.PLUS() ? '+' : '-';

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitRelationalExpression(ctx: RelationalExpressionContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    let operator: string;

    if (ctx.LESS_THAN()) {
      operator = '<';
    } else if (ctx.GREATER_THAN()) {
      operator = '>';
    } else if (ctx.LESS_EQUALS()) {
      operator = '<=';
    } else if (ctx.GREATER_EQUALS()) {
      operator = '>=';
    } else {
      operator = 'unknown';
    }

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitEqualityExpression(ctx: EqualityExpressionContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    const operator = ctx.EQUALS() ? '==' : '!=';

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitLogicalAndExpression(ctx: LogicalAndExpressionContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    const operator = '&&'; // 論理AND演算子は && のみ

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitLogicalOrExpression(ctx: LogicalOrExpressionContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    const operator = '||'; // 論理OR演算子は || のみ

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  // Primary expression visitors
  visitLiteralExpression(ctx: LiteralExpressionContext): ASTNode {
    return this.visit(ctx.literal());
  }

  visitIdentifierExpression(ctx: IdentifierExpressionContext): ASTNode {
    return {
      type: 'Identifier',
      name: ctx.IDENTIFIER().text,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitThisExpression(ctx: ThisExpressionContext): ASTNode {
    return {
      type: 'ThisExpression',
      loc: this.getLocationInfo(ctx),
    };
  }

  visitIfExpression(ctx: IfExpressionContext): ASTNode {
    const condition = this.visit(ctx.expression(0));

    // Get all expressions and blocks
    const expressions = ctx.expression();
    const blocks = ctx.block();

    // Then branch: first expression after condition OR first block
    let thenBranch: any[];
    if (blocks.length > 0 && expressions.length === 1) {
      // Format: if (cond) { block }
      const blockResult = this.visit(blocks[0]);
      thenBranch = blockResult.body;
    } else if (expressions.length > 1) {
      // Format: if (cond) expr
      thenBranch = [
        {
          type: 'ExpressionStatement',
          expression: this.visit(expressions[1]),
          loc: this.getLocationInfo(expressions[1]),
        },
      ];
    } else {
      thenBranch = [];
    }

    // Else branch: optional
    let elseBranch: any[] | undefined = undefined;
    if (ctx.ELSE()) {
      if (blocks.length > 1) {
        // Format: if (cond) { block } else { block }
        const blockResult = this.visit(blocks[1]);
        elseBranch = blockResult.body;
      } else if (blocks.length === 1 && expressions.length > 2) {
        // Format: if (cond) expr else { block }
        const blockResult = this.visit(blocks[0]);
        elseBranch = blockResult.body;
      } else if (expressions.length > 2) {
        // Format: if (cond) expr else expr
        elseBranch = [
          {
            type: 'ExpressionStatement',
            expression: this.visit(expressions[2]),
            loc: this.getLocationInfo(expressions[2]),
          },
        ];
      }
    }

    return {
      type: 'IfExpression',
      condition,
      then: thenBranch,
      else: elseBranch,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitParenthesizedExpression(ctx: ParenthesizedExpressionContext): ASTNode {
    return this.visit(ctx.expression());
  }

  visitCallExpressionPrimary(ctx: CallExpressionPrimaryContext): ASTNode {
    return this.visit(ctx.callExpression());
  }

  visitLiteral(ctx: LiteralContext): ASTNode {
    const stringLiteralCtx = ctx.stringLiteral();
    if (stringLiteralCtx) {
      return this.visit(stringLiteralCtx);
    } else if (ctx.INTEGER_LITERAL()) {
      return {
        type: 'IntegerLiteral',
        value: parseInt(ctx.INTEGER_LITERAL()!.text),
        raw: ctx.INTEGER_LITERAL()!.text,
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.TRUE()) {
      return {
        type: 'BooleanLiteral',
        value: true,
        raw: 'true',
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.FALSE()) {
      return {
        type: 'BooleanLiteral',
        value: false,
        raw: 'false',
        loc: this.getLocationInfo(ctx),
      };
    }

    return this.defaultResult();
  }

  visitStringLiteral(ctx: StringLiteralContext): ASTNode {
    if (ctx.STRING_LITERAL()) {
      const raw = ctx.STRING_LITERAL()!.text;
      return {
        type: 'StringLiteral',
        value: this.unquote(raw),
        raw,
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.DOUBLE_STRING_LITERAL()) {
      const raw = ctx.DOUBLE_STRING_LITERAL()!.text;
      return {
        type: 'StringLiteral',
        value: this.unquote(raw),
        raw,
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.templateString()) {
      return this.visit(ctx.templateString()!);
    }

    return this.defaultResult();
  }

  visitTemplateString(ctx: TemplateStringContext): ASTNode {
    const parts = ctx.templateStringContent().map((content) => this.visit(content));

    return {
      type: 'TemplateLiteral',
      parts,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitTemplateStringContent(ctx: TemplateStringContentContext): ASTNode {
    if (ctx.TEMPLATE_STRING_PART()) {
      return {
        type: 'TemplateStringPart',
        value: ctx.TEMPLATE_STRING_PART()!.text,
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.TEMPLATE_INTERPOLATION()) {
      const text = ctx.TEMPLATE_INTERPOLATION()!.text;
      const identifier = text.substring(1); // Remove the '$' prefix
      return {
        type: 'TemplateInterpolation',
        identifier,
        loc: this.getLocationInfo(ctx),
      };
    }

    return this.defaultResult();
  }

  visitAnnotation(ctx: AnnotationContext): ASTNode {
    const annotationToken = ctx.ANNOTATION();
    const nameText = annotationToken.text.substring(1); // Remove '@' prefix
    const name = {
      type: 'Identifier',
      name: nameText,
      loc: {
        start: {
          line: annotationToken.symbol.line,
          column: annotationToken.symbol.charPositionInLine + 1, // +1 to skip '@'
        },
        end: {
          line: annotationToken.symbol.line,
          column: annotationToken.symbol.charPositionInLine + annotationToken.text.length,
        },
      },
    };
    const arguments_: ASTNode[] = [];

    // Handle arguments list (e.g., @description('text', priority: 1))
    const argumentListCtx = ctx.argumentList();
    if (argumentListCtx) {
      arguments_.push(...this.visitArgumentList(argumentListCtx).arguments);
    }
    // Handle single string literal (e.g., @description 'text')
    else {
      const stringLiteralCtx = ctx.stringLiteral();
      if (stringLiteralCtx) {
        arguments_.push(this.visit(stringLiteralCtx));
      }
    }

    return {
      type: 'Annotation',
      name,
      arguments: arguments_,
      loc: this.getLocationInfo(ctx),
    };
  }
}

/**
 * Parse Canon source code and return AST
 */
export function parseCanon(source: string, filename: string = '<unknown>'): ASTNode {
  // Create input stream
  const inputStream = CharStreams.fromString(source);

  // Create lexer
  const lexer = new CanonLexer(inputStream);

  // Create token stream
  const tokenStream = new CommonTokenStream(lexer);

  // Create parser
  const parser = new CanonParser(tokenStream);

  // Parse the program
  const tree = parser.program();

  // Basic error checking - if there are no children, likely a parse error
  if (tree.childCount === 0 && source.trim().length > 0) {
    throw new Error(`Failed to parse Canon file: ${filename}`);
  }

  // Build AST
  const astBuilder = new ASTBuilder();
  return astBuilder.visit(tree);
}

/**
 * Parse Canon file and return AST
 */
export function parseCanonFile(filePath: string): ASTNode {
  const source = fs.readFileSync(filePath, 'utf-8');
  return parseCanon(source, filePath);
}

/**
 * Parse Canon source and convert to YAML
 */
export function parseCanonToYaml(source: string, filename: string = '<unknown>'): string {
  const ast = parseCanon(source, filename);
  return yaml.dump(ast, {
    indent: 2,
    lineWidth: -1,
    sortKeys: false,
  });
}

/**
 * Parse Canon file and convert to YAML
 */
export function parseCanonFileToYaml(filePath: string): string {
  const ast = parseCanonFile(filePath);
  return yaml.dump(ast, {
    indent: 2,
    lineWidth: -1,
    sortKeys: false,
  });
}

/**
 * Parse Canon file and write AST to YAML file
 */
export function parseCanonFileToYamlFile(
  inputFilePath: string,
  outputFilePath: string = 'ast.yml'
): void {
  const yamlContent = parseCanonFileToYaml(inputFilePath);
  fs.writeFileSync(outputFilePath, yamlContent, 'utf-8');
  console.log(`✅ AST written to ${outputFilePath}`);
}

/**
 * Parse Canon source and write AST to YAML file
 */
export function parseCanonToYamlFile(
  source: string,
  outputFilePath: string = 'ast.yml',
  filename: string = '<unknown>'
): void {
  const yamlContent = parseCanonToYaml(source, filename);
  fs.writeFileSync(outputFilePath, yamlContent, 'utf-8');
  console.log(`✅ AST written to ${outputFilePath}`);
}

// Main execution when this file is run directly
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log('Usage: npx tsx src/parser.ts <input-file> [output-file]');
    console.log('');
    console.log('Examples:');
    console.log('  npx tsx src/parser.ts definition/schema.canon');
    console.log('  npx tsx src/parser.ts input.canon output.yaml');
    process.exit(1);
  }

  const inputFile = args[0];
  const outputFile = args[1] || 'ast.yaml';

  if (!fs.existsSync(inputFile)) {
    console.error(`❌ Error: Input file "${inputFile}" does not exist.`);
    process.exit(1);
  }

  try {
    parseCanonFileToYamlFile(inputFile, outputFile);
  } catch (error) {
    console.error(`❌ Error parsing file: ${error}`);
    process.exit(1);
  }
}
