import * as fs from 'fs';
import * as yaml from 'js-yaml';
import { CharStreams, CommonTokenStream } from 'antlr4ts';
import { AbstractParseTreeVisitor } from 'antlr4ts/tree/AbstractParseTreeVisitor';
import { RuleNode } from 'antlr4ts/tree/RuleNode';
import { CanonLexer } from './generated/CanonLexer';
import {
  CanonParser,
  ProgramContext,
  SchemaDirectiveContext,
  UseStatementContext,
  TopLevelElementContext,
  SchemaDeclarationContext,
  StructDeclarationContext,
  UnionDeclarationContext,
  TypeDeclarationContext,
  UnionTypeContext,
  TypeContext,
  BaseTypeContext,
  PrimitiveTypeContext,
  BlockContext,
  BlockContentContext,
  PropertyDeclarationContext,
  AssignmentStatementContext,
  InitDeclarationContext,
  FunctionDeclarationContext,
  GetterDeclarationContext,
  RepeatedDeclarationContext,
  MappingBlockContext,
  MappingEntryContext,
  ParameterListContext,
  ParameterContext,
  ObjectInstantiationContext,
  ArgumentListContext,
  IfStatementContext,
  ExpressionStatementContext,
  PrimaryContext,
  LiteralContext,
  StringLiteralContext,
  TemplateStringContext,
  TemplateStringContentContext,
  AnnotationContext,
  PrimaryExpressionContext,
  MemberAccessExpressionContext,
  FunctionCallExpressionContext,
  UnaryMinusExpressionContext,
  LogicalNotExpressionContext,
  MultiplicativeExpressionContext,
  AdditiveExpressionContext,
  RelationalExpressionContext,
  EqualityExpressionContext,
  LogicalAndExpressionContext,
  LogicalOrExpressionContext,
} from './generated/CanonParser';
import { CanonParserVisitor } from './generated/CanonParserVisitor';

export interface ASTLocation {
  start: { line: number; column: number };
  end: { line: number; column: number };
}

export interface ASTNode {
  type: string;
  [key: string]: any;
}

/**
 * AST Builder that converts ANTLR parse tree to AST using visitor pattern.
 *
 * This class implements the visitor pattern to traverse the Concrete Syntax Tree (CST)
 * generated by ANTLR and converts it into a more usable Abstract Syntax Tree (AST).
 *
 * Key responsibilities:
 * - Transform context objects into standardized AST nodes
 * - Extract location information for error reporting
 * - Handle null safety for optional grammar elements
 * - Apply semantic transformations (e.g., unquoting strings)
 * - Maintain structural integrity of the Canon language semantics
 */
class ASTBuilder extends AbstractParseTreeVisitor<ASTNode> implements CanonParserVisitor<ASTNode> {
  defaultResult(): ASTNode {
    return { type: 'Unknown' };
  }

  /**
   * Extracts location information from ANTLR context nodes.
   * @param node - ANTLR context node
   * @returns Location information or undefined if extraction fails
   */
  private getLocationInfo(node: any): ASTLocation | undefined {
    try {
      if (node && node.start && node.stop) {
        return {
          start: {
            line: node.start.line,
            column: node.start.charPositionInLine,
          },
          end: {
            line: node.stop.line,
            column: node.stop.charPositionInLine + (node.stop.text?.length || 0),
          },
        };
      }
    } catch {
      // If location extraction fails, return undefined
    }
    return undefined;
  }

  /**
   * Removes surrounding quotes from string literals.
   * Handles both single and double quoted strings.
   * @param text - Quoted string text
   * @returns Unquoted string content
   */
  private unquote(text: string): string {
    if (
      (text.startsWith("'") && text.endsWith("'")) ||
      (text.startsWith('"') && text.endsWith('"'))
    ) {
      return text.slice(1, -1);
    }
    return text;
  }

  visitProgram(ctx: ProgramContext): ASTNode {
    const children: ASTNode[] = [];

    for (let i = 0; i < ctx.childCount; i++) {
      const child = ctx.getChild(i);
      if (child instanceof RuleNode) {
        const result = this.visit(child);
        if (result && result.type !== 'Unknown') {
          children.push(result);
        }
      }
    }

    return {
      type: 'Program',
      body: children,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitSchemaDirective(ctx: SchemaDirectiveContext): ASTNode {
    const pathNode = this.visit(ctx.stringLiteral());
    return {
      type: 'SchemaDirective',
      path: pathNode.value,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitUseStatement(ctx: UseStatementContext): ASTNode {
    return {
      type: 'UseStatement',
      identifier: ctx.IDENTIFIER().text,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitTopLevelElement(ctx: TopLevelElementContext): ASTNode {
    // TopLevelElement is a choice rule, so we visit the actual content
    for (let i = 0; i < ctx.childCount; i++) {
      const child = ctx.getChild(i);
      if (child instanceof RuleNode) {
        return this.visit(child);
      }
    }
    return this.defaultResult();
  }

  visitSchemaDeclaration(ctx: SchemaDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const body = this.visit(ctx.block());

    return {
      type: 'SchemaDeclaration',
      annotations,
      body: body.content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitStructDeclaration(ctx: StructDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const name = ctx.IDENTIFIER().text;
    const body = this.visit(ctx.block());

    return {
      type: 'StructDeclaration',
      name,
      annotations,
      body: body.content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitUnionDeclaration(ctx: UnionDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const name = ctx.IDENTIFIER().text;
    const unionType = this.visit(ctx.unionType());

    return {
      type: 'UnionDeclaration',
      name,
      annotations,
      unionType,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitTypeDeclaration(ctx: TypeDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const name = ctx.IDENTIFIER().text;
    const typeRef = this.visit(ctx.type());

    return {
      type: 'TypeDeclaration',
      name,
      annotations,
      typeRef,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitUnionType(ctx: UnionTypeContext): ASTNode {
    const types = ctx.type().map((t) => this.visit(t));

    return {
      type: 'UnionType',
      types,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitType(ctx: TypeContext): ASTNode {
    const baseType = this.visit(ctx.baseType());
    const arrayDimensions = ctx.LBRACKET().length;

    if (arrayDimensions > 0) {
      return {
        type: 'ArrayType',
        elementType: baseType,
        dimensions: arrayDimensions,
        loc: this.getLocationInfo(ctx),
      };
    }

    return baseType;
  }

  visitBaseType(ctx: BaseTypeContext): ASTNode {
    if (ctx.primitiveType()) {
      return this.visit(ctx.primitiveType()!);
    } else {
      return {
        type: 'TypeReference',
        name: ctx.IDENTIFIER()!.text,
        loc: this.getLocationInfo(ctx),
      };
    }
  }

  visitPrimitiveType(ctx: PrimitiveTypeContext): ASTNode {
    let typeName: string;
    if (ctx.STRING_TYPE()) {
      typeName = 'string';
    } else if (ctx.INT_TYPE()) {
      typeName = 'int';
    } else if (ctx.BOOL_TYPE()) {
      typeName = 'bool';
    } else {
      typeName = 'unknown';
    }

    return {
      type: 'PrimitiveType',
      name: typeName,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitBlock(ctx: BlockContext): ASTNode {
    const content = ctx.blockContent().map((bc) => this.visit(bc));

    return {
      type: 'Block',
      content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitBlockContent(ctx: BlockContentContext): ASTNode {
    // BlockContent is a choice rule, so we visit the actual content
    for (let i = 0; i < ctx.childCount; i++) {
      const child = ctx.getChild(i);
      if (child instanceof RuleNode) {
        return this.visit(child);
      }
    }
    return this.defaultResult();
  }

  visitPropertyDeclaration(ctx: PropertyDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const isPrivate = ctx.PRIVATE() !== undefined;
    const name = ctx.IDENTIFIER().text;
    const isOptional = ctx.QUESTION() !== undefined;
    const typeRef = ctx.type() ? this.visit(ctx.type()!) : undefined;
    const defaultValue = ctx.expression() ? this.visit(ctx.expression()!) : undefined;

    return {
      type: 'PropertyDeclaration',
      name,
      annotations,
      isPrivate,
      isOptional,
      typeRef,
      defaultValue,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitAssignmentStatement(ctx: AssignmentStatementContext): ASTNode {
    const isThisAccess = ctx.THIS() !== undefined;
    const name = ctx.IDENTIFIER().text;
    const value = this.visit(ctx.expression());

    return {
      type: 'AssignmentStatement',
      name,
      isThisAccess,
      value,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitInitDeclaration(ctx: InitDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const paramList = ctx.parameterList();
    const parameters = paramList
      ? this.visit(paramList)
      : { type: 'ParameterList', parameters: [] };
    const body = this.visit(ctx.block());

    return {
      type: 'InitDeclaration',
      annotations,
      parameters: parameters.parameters,
      body: body.content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitFunctionDeclaration(ctx: FunctionDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const isPrivate = ctx.PRIVATE() !== undefined;
    const name = ctx.IDENTIFIER().text;
    const paramList = ctx.parameterList();
    const parameters = paramList
      ? this.visit(paramList)
      : { type: 'ParameterList', parameters: [] };
    const body = this.visit(ctx.block());

    return {
      type: 'FunctionDeclaration',
      name,
      annotations,
      isPrivate,
      parameters: parameters.parameters,
      body: body.content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitGetterDeclaration(ctx: GetterDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const name = ctx.IDENTIFIER().text;
    const body = this.visit(ctx.block());

    return {
      type: 'GetterDeclaration',
      name,
      annotations,
      body: body.content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitRepeatedDeclaration(ctx: RepeatedDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const name = ctx.IDENTIFIER().text;
    const typeRef = this.visit(ctx.type());
    const mappingBlock = ctx.mappingBlock();
    const mapping = mappingBlock ? this.visit(mappingBlock) : undefined;
    const expressionCtx = ctx.expression();
    const defaultValue = expressionCtx ? this.visit(expressionCtx) : undefined;

    return {
      type: 'RepeatedDeclaration',
      name,
      annotations,
      typeRef,
      mapping,
      defaultValue,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitMappingBlock(ctx: MappingBlockContext): ASTNode {
    const entries = ctx.mappingEntry().map((entry) => this.visit(entry));

    return {
      type: 'MappingBlock',
      entries,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitMappingEntry(ctx: MappingEntryContext): ASTNode {
    const from = ctx.IDENTIFIER(0).text;
    const to = ctx.IDENTIFIER(1).text;

    return {
      type: 'MappingEntry',
      from,
      to,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitParameterList(ctx: ParameterListContext): ASTNode {
    const parameters = ctx.parameter().map((param) => this.visit(param));

    return {
      type: 'ParameterList',
      parameters,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitParameter(ctx: ParameterContext): ASTNode {
    const isThisParameter = ctx.THIS() !== undefined;
    const name = ctx.IDENTIFIER().text;
    const typeCtx = ctx.type();
    const typeRef = typeCtx ? this.visit(typeCtx) : undefined;

    return {
      type: 'Parameter',
      name,
      isThisParameter,
      typeRef,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitObjectInstantiation(ctx: ObjectInstantiationContext): ASTNode {
    const typeName = ctx.IDENTIFIER().text;
    const argList = ctx.argumentList();
    const args = argList ? this.visit(argList) : { type: 'ArgumentList', arguments: [] };
    const body = this.visit(ctx.block());

    return {
      type: 'ObjectInstantiation',
      typeName,
      arguments: args.arguments,
      body: body.content,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitArgumentList(ctx: ArgumentListContext): ASTNode {
    const args = ctx.expression().map((expr) => this.visit(expr));

    return {
      type: 'ArgumentList',
      arguments: args,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitIfStatement(ctx: IfStatementContext): ASTNode {
    const condition = this.visit(ctx.expression(0));
    const then = this.visit(ctx.expression(1));

    return {
      type: 'IfStatement',
      condition,
      then,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitExpressionStatement(ctx: ExpressionStatementContext): ASTNode {
    return this.visit(ctx.expression());
  }

  // Expression visitors
  visitPrimaryExpression(ctx: PrimaryExpressionContext): ASTNode {
    return this.visit(ctx.primary());
  }

  visitMemberAccessExpression(ctx: MemberAccessExpressionContext): ASTNode {
    const object = this.visit(ctx.expression());
    const property = ctx.IDENTIFIER().text;

    return {
      type: 'MemberAccessExpression',
      object,
      property,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitFunctionCallExpression(ctx: FunctionCallExpressionContext): ASTNode {
    const callee = this.visit(ctx.expression());
    const argList = ctx.argumentList();
    const args = argList ? this.visit(argList) : { type: 'ArgumentList', arguments: [] };

    return {
      type: 'FunctionCallExpression',
      callee,
      arguments: args.arguments,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitUnaryMinusExpression(ctx: UnaryMinusExpressionContext): ASTNode {
    const operand = this.visit(ctx.expression());

    return {
      type: 'UnaryExpression',
      operator: '-',
      operand,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitLogicalNotExpression(ctx: LogicalNotExpressionContext): ASTNode {
    const operand = this.visit(ctx.expression());

    return {
      type: 'UnaryExpression',
      operator: 'not',
      operand,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitMultiplicativeExpression(ctx: MultiplicativeExpressionContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    let operator: string;

    if (ctx.MULTIPLY()) {
      operator = '*';
    } else if (ctx.DIVIDE()) {
      operator = '/';
    } else if (ctx.MODULO()) {
      operator = '%';
    } else {
      operator = 'unknown';
    }

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitAdditiveExpression(ctx: AdditiveExpressionContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    const operator = ctx.PLUS() ? '+' : '-';

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitRelationalExpression(ctx: RelationalExpressionContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    let operator: string;

    if (ctx.LESS_THAN()) {
      operator = '<';
    } else if (ctx.GREATER_THAN()) {
      operator = '>';
    } else if (ctx.LESS_EQUALS()) {
      operator = '<=';
    } else if (ctx.GREATER_EQUALS()) {
      operator = '>=';
    } else {
      operator = 'unknown';
    }

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitEqualityExpression(ctx: EqualityExpressionContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    const operator = ctx.EQUALS() ? '==' : '!=';

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitLogicalAndExpression(ctx: LogicalAndExpressionContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    const operator = ctx.AND() ? 'and' : '&&';

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitLogicalOrExpression(ctx: LogicalOrExpressionContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    const operator = ctx.OR() ? 'or' : '||';

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitPrimary(ctx: PrimaryContext): ASTNode {
    if (ctx.literal()) {
      return this.visit(ctx.literal()!);
    } else if (ctx.IDENTIFIER()) {
      return {
        type: 'Identifier',
        name: ctx.IDENTIFIER()!.text,
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.THIS()) {
      return {
        type: 'ThisExpression',
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.expression()) {
      return this.visit(ctx.expression()!);
    } else if (ctx.objectInstantiation()) {
      return this.visit(ctx.objectInstantiation()!);
    } else if (ctx.ERROR()) {
      const message = this.visit(ctx.stringLiteral()!);
      return {
        type: 'ErrorExpression',
        message: message.value,
        loc: this.getLocationInfo(ctx),
      };
    }

    return this.defaultResult();
  }

  visitLiteral(ctx: LiteralContext): ASTNode {
    const stringLiteralCtx = ctx.stringLiteral();
    if (stringLiteralCtx) {
      return this.visit(stringLiteralCtx);
    } else if (ctx.INTEGER_LITERAL()) {
      return {
        type: 'IntegerLiteral',
        value: parseInt(ctx.INTEGER_LITERAL()!.text),
        raw: ctx.INTEGER_LITERAL()!.text,
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.TRUE()) {
      return {
        type: 'BooleanLiteral',
        value: true,
        raw: 'true',
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.FALSE()) {
      return {
        type: 'BooleanLiteral',
        value: false,
        raw: 'false',
        loc: this.getLocationInfo(ctx),
      };
    }

    return this.defaultResult();
  }

  visitStringLiteral(ctx: StringLiteralContext): ASTNode {
    if (ctx.STRING_LITERAL()) {
      const raw = ctx.STRING_LITERAL()!.text;
      return {
        type: 'StringLiteral',
        value: this.unquote(raw),
        raw,
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.DOUBLE_STRING_LITERAL()) {
      const raw = ctx.DOUBLE_STRING_LITERAL()!.text;
      return {
        type: 'StringLiteral',
        value: this.unquote(raw),
        raw,
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.templateString()) {
      return this.visit(ctx.templateString()!);
    }

    return this.defaultResult();
  }

  visitTemplateString(ctx: TemplateStringContext): ASTNode {
    const parts = ctx.templateStringContent().map((content) => this.visit(content));

    return {
      type: 'TemplateLiteral',
      parts,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitTemplateStringContent(ctx: TemplateStringContentContext): ASTNode {
    if (ctx.TEMPLATE_STRING_PART()) {
      return {
        type: 'TemplateStringPart',
        value: ctx.TEMPLATE_STRING_PART()!.text,
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.TEMPLATE_INTERPOLATION()) {
      const text = ctx.TEMPLATE_INTERPOLATION()!.text;
      const identifier = text.substring(1); // Remove the '$' prefix
      return {
        type: 'TemplateInterpolation',
        identifier,
        loc: this.getLocationInfo(ctx),
      };
    }

    return this.defaultResult();
  }

  visitAnnotation(ctx: AnnotationContext): ASTNode {
    const name = ctx.ANNOTATION().text.substring(1); // Remove '@' prefix
    const stringLiteralCtx = ctx.stringLiteral();
    const value = stringLiteralCtx ? this.visit(stringLiteralCtx) : undefined;

    return {
      type: 'Annotation',
      name,
      value: value?.value,
      loc: this.getLocationInfo(ctx),
    };
  }
}

/**
 * Parse Canon source code and return AST
 */
export function parseCanon(source: string, filename: string = '<unknown>'): ASTNode {
  // Create input stream
  const inputStream = CharStreams.fromString(source);

  // Create lexer
  const lexer = new CanonLexer(inputStream);

  // Create token stream
  const tokenStream = new CommonTokenStream(lexer);

  // Create parser
  const parser = new CanonParser(tokenStream);

  // Parse the program
  const tree = parser.program();

  // Basic error checking - if there are no children, likely a parse error
  if (tree.childCount === 0 && source.trim().length > 0) {
    throw new Error(`Failed to parse Canon file: ${filename}`);
  }

  // Build AST
  const astBuilder = new ASTBuilder();
  return astBuilder.visit(tree);
}

/**
 * Parse Canon file and return AST
 */
export function parseCanonFile(filePath: string): ASTNode {
  const source = fs.readFileSync(filePath, 'utf-8');
  return parseCanon(source, filePath);
}

/**
 * Parse Canon source and convert to YAML
 */
export function parseCanonToYaml(source: string, filename: string = '<unknown>'): string {
  const ast = parseCanon(source, filename);
  return yaml.dump(ast, {
    indent: 2,
    lineWidth: -1,
    sortKeys: false,
  });
}

/**
 * Parse Canon file and convert to YAML
 */
export function parseCanonFileToYaml(filePath: string): string {
  const ast = parseCanonFile(filePath);
  return yaml.dump(ast, {
    indent: 2,
    lineWidth: -1,
    sortKeys: false,
  });
}
