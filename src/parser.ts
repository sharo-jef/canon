import * as fs from 'fs';
import * as yaml from 'js-yaml';
import { CharStreams, CommonTokenStream } from 'antlr4ts';
import { AbstractParseTreeVisitor } from 'antlr4ts/tree/AbstractParseTreeVisitor';
import { RuleNode } from 'antlr4ts/tree/RuleNode';
import { CanonLexer } from './generated/CanonLexer';
import {
  CanonParser,
  ProgramContext,
  ProgramElementContext,
  SchemaDirectiveContext,
  UseStatementContext,
  TopLevelStatementContext,
  TopLevelElementContext,
  SchemaDeclarationContext,
  StructDeclarationContext,
  StructBodyContext,
  StructMemberContext,
  UnionDeclarationContext,
  TypeDeclarationContext,
  VariableDeclarationContext,
  TypeContext,
  BaseTypeContext,
  PrimitiveTypeContext,
  FunctionTypeContext,
  BlockContext,
  StatementContext,
  PropertyDeclarationContext,
  AssignmentStatementContext,
  InitDeclarationContext,
  FunctionDeclarationContext,
  GetterDeclarationContext,
  MethodDeclarationContext,
  RepeatedDeclarationContext,
  MixinDeclarationContext,
  MappingBlockContext,
  MappingEntryContext,
  ParameterListContext,
  ParameterContext,
  CallExpressionContext,
  ArgumentListContext,
  ExpressionStatementContext,
  LiteralContext,
  StringLiteralContext,
  TemplateStringContext,
  TemplateStringContentContext,
  AnnotationContext,
  PrimaryExprContext,
  MemberAccessExprContext,
  FuncCallExprContext,
  NonNullAssertExprContext,
  UnaryMinusExprContext,
  LogicalNotExprContext,
  MulDivModExprContext,
  AddSubExprContext,
  RelationalExprContext,
  EqualityExprContext,
  LogicalAndExprContext,
  LogicalOrExprContext,
  LiteralExprContext,
  IdentifierExprContext,
  ThisExprContext,
  IfExprContext,
  ParenExprContext,
  CallExprPrimaryContext,
  ListLiteralContext,
  ListLiteralExprContext,
  LambdaExpressionContext,
  LambdaParametersContext,
  LambdaParameterContext,
  LambdaBodyContext,
  LambdaExprContext,
  AnonymousFunctionContext,
  AnonFuncExprContext,
  SpreadExpressionContext,
  SpreadExprContext,
  PipelineExprContext,
  SliceExprContext,
  BitwiseAndExprContext,
  BitwiseXorExprContext,
  BitwiseOrExprContext,
  ShiftExprContext,
  IndexAccessExprContext,
  BitwiseNotExprContext,
  PowerExprContext,
  RangeExprContext,
  InfixCallExprContext,
  TypeCastExprContext,
} from './generated/CanonParser';
import { CanonParserVisitor } from './generated/CanonParserVisitor';
import { CanonErrorListener } from './error/CanonErrorListener';
import { ErrorFormatter } from './error/ErrorFormatter';

export interface ASTLocation {
  start: { line: number; column: number };
  end: { line: number; column: number };
}

export interface ASTNode {
  type: string;
  [key: string]: any;
}

/**
 * AST Builder that converts ANTLR parse tree to AST using visitor pattern.
 *
 * This class implements the visitor pattern to traverse the Concrete Syntax Tree (CST)
 * generated by ANTLR and converts it into a more usable Abstract Syntax Tree (AST).
 *
 * Key responsibilities:
 * - Transform context objects into standardized AST nodes
 * - Extract location information for error reporting
 * - Handle null safety for optional grammar elements
 * - Apply semantic transformations (e.g., unquoting strings)
 * - Maintain structural integrity of the Canon language semantics
 */
class ASTBuilder extends AbstractParseTreeVisitor<ASTNode> implements CanonParserVisitor<ASTNode> {
  defaultResult(): ASTNode {
    return { type: 'Unknown' };
  }

  /**
   * Extracts location information from ANTLR context nodes.
   * @param node - ANTLR context node
   * @returns Location information or undefined if extraction fails
   */
  private getLocationInfo(node: any): ASTLocation | undefined {
    try {
      if (node && node.start && node.stop) {
        return {
          start: {
            line: node.start.line,
            column: node.start.charPositionInLine,
          },
          end: {
            line: node.stop.line,
            column: node.stop.charPositionInLine + (node.stop.text?.length || 0),
          },
        };
      }
    } catch {
      // If location extraction fails, return undefined
    }
    return undefined;
  }

  /**
   * Removes surrounding quotes from string literals.
   * Handles both single and double quoted strings.
   * @param text - Quoted string text
   * @returns Unquoted string content
   */
  private unquote(text: string): string {
    if (
      (text.startsWith("'") && text.endsWith("'")) ||
      (text.startsWith('"') && text.endsWith('"'))
    ) {
      return text.slice(1, -1);
    }
    return text;
  }

  visitProgram(ctx: ProgramContext): ASTNode {
    const children: ASTNode[] = [];

    for (let i = 0; i < ctx.childCount; i++) {
      const child = ctx.getChild(i);
      if (child instanceof RuleNode) {
        const ruleName = child.ruleContext?.constructor.name;
        if (ruleName === 'ProgramElementContext') {
          const result = this.visit(child);
          if (result && result.type !== 'Unknown') {
            children.push(result);
          }
        }
        // Skip StatementSeparatorsContext and newline tokens
      }
    }

    return {
      type: 'Program',
      body: children,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitSchemaDirective(ctx: SchemaDirectiveContext): ASTNode {
    const pathNode = this.visit(ctx.stringLiteral());
    return {
      type: 'SchemaDirective',
      path: pathNode.value,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitUseStatement(ctx: UseStatementContext): ASTNode {
    const identifierToken = ctx.IDENTIFIER();
    return {
      type: 'UseStatement',
      identifier: {
        type: 'Identifier',
        name: identifierToken.text,
        loc: {
          start: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine,
          },
          end: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
          },
        },
      },
      loc: this.getLocationInfo(ctx),
    };
  }

  visitTopLevelElement(ctx: TopLevelElementContext): ASTNode {
    // TopLevelElement is a choice rule, so we visit the actual content
    for (let i = 0; i < ctx.childCount; i++) {
      const child = ctx.getChild(i);
      if (child instanceof RuleNode) {
        return this.visit(child);
      }
    }
    return this.defaultResult();
  }

  visitTopLevelStatement(ctx: TopLevelStatementContext): ASTNode {
    // For TopLevelStatement, we need to visit all its elements
    // and return them as a wrapper or handle them in visitProgram

    // Since this is a container rule, we'll visit all children
    // and collect the results, but we need to return a single ASTNode
    const elements: ASTNode[] = [];

    for (let i = 0; i < ctx.childCount; i++) {
      const child = ctx.getChild(i);
      if (child instanceof RuleNode) {
        const ruleName = child.ruleContext?.constructor.name;
        if (ruleName === 'TopLevelElementContext') {
          const result = this.visit(child);
          if (result && result.type !== 'Unknown') {
            elements.push(result);
          }
        }
        // Skip StatementSeparatorsContext nodes
      }
    }

    // Return the elements as a special container
    return {
      type: 'TopLevelStatement',
      elements: elements,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitSchemaDeclaration(ctx: SchemaDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));

    // Handle both block and string literal forms
    const blockCtx = ctx.block();
    const stringLiteralCtx = ctx.stringLiteral();

    if (blockCtx) {
      const body = this.visit(blockCtx);
      return {
        type: 'SchemaDeclaration',
        annotations,
        body: body.body || [],
        loc: this.getLocationInfo(ctx),
      };
    } else if (stringLiteralCtx) {
      const path = this.visit(stringLiteralCtx);
      return {
        type: 'SchemaImport',
        annotations,
        path,
        loc: this.getLocationInfo(ctx),
      };
    } else {
      throw new Error('SchemaDeclaration must have either block or stringLiteral');
    }
  }

  visitStructDeclaration(ctx: StructDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const body = this.visit(ctx.structBody());

    return {
      type: 'StructDeclaration',
      name,
      annotations,
      body: body.body || [],
      loc: this.getLocationInfo(ctx),
    };
  }

  visitStructBody(ctx: StructBodyContext): ASTNode {
    const members = ctx.structMember().map((member) => this.visit(member));
    return {
      type: 'StructBody',
      body: members,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitStructMember(ctx: StructMemberContext): ASTNode {
    // structMember can be one of: propertyDeclaration, initDeclaration, getterDeclaration, methodDeclaration, repeatedDeclaration, mixinDeclaration
    if (ctx.propertyDeclaration()) {
      return this.visit(ctx.propertyDeclaration()!);
    } else if (ctx.initDeclaration()) {
      return this.visit(ctx.initDeclaration()!);
    } else if (ctx.getterDeclaration()) {
      return this.visit(ctx.getterDeclaration()!);
    } else if (ctx.methodDeclaration()) {
      return this.visit(ctx.methodDeclaration()!);
    } else if (ctx.repeatedDeclaration()) {
      return this.visit(ctx.repeatedDeclaration()!);
    } else if (ctx.mixinDeclaration()) {
      return this.visit(ctx.mixinDeclaration()!);
    } else {
      throw new Error('Unknown struct member type');
    }
  }

  visitUnionDeclaration(ctx: UnionDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const types = ctx
      .unionType()
      .type()
      .map((t) => this.visit(t));

    return {
      type: 'UnionDeclaration',
      name,
      annotations,
      types,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitTypeDeclaration(ctx: TypeDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const typeRef = this.visit(ctx.type());

    return {
      type: 'TypeDeclaration',
      name,
      annotations,
      typeRef,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitVariableDeclaration(ctx: VariableDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const isVal = ctx.VAL() !== undefined;
    const isVar = ctx.VAR() !== undefined;
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };

    // Determine the kind of variable declaration
    let kind: string;
    if (isVal && isVar) {
      throw new Error('Variable declaration cannot be both val and var');
    } else if (isVal) {
      kind = 'val';
    } else if (isVar) {
      kind = 'var';
    } else {
      throw new Error('Variable declaration must be either val or var');
    }

    const typeCtx = ctx.type();
    const typeRef = typeCtx ? this.visit(typeCtx) : null;
    const value = this.visit(ctx.expression());

    return {
      type: 'VariableDeclaration',
      kind,
      name,
      typeRef,
      value,
      annotations,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitType(ctx: TypeContext): ASTNode {
    const baseType = this.visit(ctx.baseType());
    const arrayDimensions = ctx.LBRACKET().length;

    // デバッグ: QUESTION()の値を確認
    const questionToken = ctx.QUESTION();
    const isNullable = questionToken !== null && questionToken !== undefined;

    let resultType = baseType;

    // Handle array dimensions
    if (arrayDimensions > 0) {
      resultType = {
        type: 'ArrayType',
        elementType: baseType,
        dimensions: arrayDimensions,
        loc: this.getLocationInfo(ctx),
      };
    }

    // Handle nullable type
    if (isNullable) {
      resultType = {
        type: 'NullableType',
        innerType: resultType,
        loc: this.getLocationInfo(ctx),
      };
    }

    return resultType;
  }

  visitBaseType(ctx: BaseTypeContext): ASTNode {
    if (ctx.primitiveType()) {
      return this.visit(ctx.primitiveType()!);
    } else if (ctx.functionType()) {
      return this.visit(ctx.functionType()!);
    } else {
      const identifierToken = ctx.IDENTIFIER()!;
      return {
        type: 'TypeReference',
        name: {
          type: 'Identifier',
          name: identifierToken.text,
          loc: {
            start: {
              line: identifierToken.symbol.line,
              column: identifierToken.symbol.charPositionInLine,
            },
            end: {
              line: identifierToken.symbol.line,
              column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
            },
          },
        },
        loc: this.getLocationInfo(ctx),
      };
    }
  }

  visitFunctionType(ctx: FunctionTypeContext): ASTNode {
    // FunctionType: LPAREN (type (COMMA type)*)? RPAREN ARROW type
    const paramTypes: ASTNode[] = [];

    // Get all type nodes from the function type
    const typeNodes = ctx.type();

    // The last type is the return type, all others are parameter types
    if (typeNodes.length > 0) {
      for (let i = 0; i < typeNodes.length - 1; i++) {
        paramTypes.push(this.visit(typeNodes[i]));
      }

      const returnType = this.visit(typeNodes[typeNodes.length - 1]);

      return {
        type: 'FunctionType',
        parameterTypes: paramTypes,
        returnType: returnType,
        loc: this.getLocationInfo(ctx),
      };
    } else {
      // No parameters, no return type (should not happen with valid grammar)
      return {
        type: 'FunctionType',
        parameterTypes: [],
        returnType: {
          type: 'PrimitiveType',
          name: 'null',
          loc: this.getLocationInfo(ctx),
        },
        loc: this.getLocationInfo(ctx),
      };
    }
  }

  visitPrimitiveType(ctx: PrimitiveTypeContext): ASTNode {
    let typeName: string;
    if (ctx.STRING_TYPE()) {
      typeName = 'string';
    } else if (ctx.INT_TYPE()) {
      typeName = 'int';
    } else if (ctx.BOOL_TYPE()) {
      typeName = 'bool';
    } else if (ctx.FLOAT_TYPE()) {
      typeName = 'float';
    } else if (ctx.NULL_TYPE()) {
      typeName = 'null';
    } else {
      typeName = 'unknown';
    }

    return {
      type: 'PrimitiveType',
      name: typeName,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitBlock(ctx: BlockContext): ASTNode {
    // New grammar: block: LBRACE (statement (SEMICOLON statement)*)* RBRACE;
    const statements: ASTNode[] = [];

    // Get all statement nodes from the block
    const statementNodes = ctx.statement();

    for (const stmt of statementNodes) {
      const result = this.visit(stmt);
      if (result) {
        statements.push(result);
      }
    }

    return {
      type: 'Block',
      body: statements,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitStatement(ctx: StatementContext): ASTNode {
    // statement is a choice rule, so we visit the actual content
    for (let i = 0; i < ctx.childCount; i++) {
      const child = ctx.getChild(i);
      if (child instanceof RuleNode) {
        return this.visit(child);
      }
    }
    return this.defaultResult();
  }
  visitPropertyDeclaration(ctx: PropertyDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const isPrivate = ctx.PRIVATE() !== undefined;
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const isOptional = ctx.QUESTION() !== undefined;

    let typeRef: ASTNode | undefined;
    if (ctx.type()) {
      typeRef = this.visit(ctx.type()!);
    } else {
      // 型が省略されている場合、プロパティ名と同じ名前の TypeReference を生成
      typeRef = {
        type: 'TypeReference',
        name: {
          type: 'Identifier',
          name: identifierToken.text,
          loc: {
            start: {
              line: identifierToken.symbol.line,
              column: identifierToken.symbol.charPositionInLine,
            },
            end: {
              line: identifierToken.symbol.line,
              column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
            },
          },
        },
        loc: {
          start: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine,
          },
          end: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
          },
        },
      };
    }

    const defaultValue = ctx.expression() ? this.visit(ctx.expression()!) : undefined;

    return {
      type: 'PropertyDeclaration',
      name,
      annotations,
      isPrivate,
      isOptional,
      typeRef,
      defaultValue,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitAssignmentStatement(ctx: AssignmentStatementContext): ASTNode {
    const value = this.visit(ctx.expression());

    // Determine the assignment operator
    const operator = ctx.ASSIGN() ? '=' : '+=';

    let left: ASTNode;
    if (ctx.THIS()) {
      // this.identifier の場合はMemberAccessExpressionとして表現
      left = {
        type: 'MemberAccessExpression',
        object: {
          type: 'ThisExpression',
          loc: {
            start: {
              line: ctx.THIS()!.symbol.line,
              column: ctx.THIS()!.symbol.charPositionInLine,
            },
            end: {
              line: ctx.THIS()!.symbol.line,
              column: ctx.THIS()!.symbol.charPositionInLine + 4, // "this".length
            },
          },
        },
        property: {
          type: 'Identifier',
          name: ctx.IDENTIFIER().text,
          loc: {
            start: {
              line: ctx.IDENTIFIER().symbol.line,
              column: ctx.IDENTIFIER().symbol.charPositionInLine,
            },
            end: {
              line: ctx.IDENTIFIER().symbol.line,
              column: ctx.IDENTIFIER().symbol.charPositionInLine + ctx.IDENTIFIER().text.length,
            },
          },
        },
        computed: false,
        loc: this.getLocationInfo(ctx),
      };
    } else {
      // identifier の場合はIdentifierとして表現
      left = {
        type: 'Identifier',
        name: ctx.IDENTIFIER().text,
        loc: {
          start: {
            line: ctx.IDENTIFIER().symbol.line,
            column: ctx.IDENTIFIER().symbol.charPositionInLine,
          },
          end: {
            line: ctx.IDENTIFIER().symbol.line,
            column: ctx.IDENTIFIER().symbol.charPositionInLine + ctx.IDENTIFIER().text.length,
          },
        },
      };
    }

    return {
      type: 'AssignmentStatement',
      operator,
      left,
      right: value,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitInitDeclaration(ctx: InitDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const paramList = ctx.parameterList();
    const parameters = paramList
      ? this.visit(paramList)
      : { type: 'ParameterList', parameters: [] };
    const body = this.visit(ctx.block());

    return {
      type: 'InitDeclaration',
      annotations,
      parameters: parameters.parameters,
      body: body.body || [],
      loc: this.getLocationInfo(ctx),
    };
  }

  visitFunctionDeclaration(ctx: FunctionDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const isInfix = ctx.INFIX() !== undefined;

    let name: ASTNode;
    let receiverType: ASTNode | null = null;

    if (isInfix) {
      // For infix functions: infix fun Type.functionName
      const types = ctx.type();
      receiverType = types.length > 0 ? this.visit(types[0]) : null;
      const identifierToken = ctx.IDENTIFIER();
      if (!identifierToken) {
        throw new Error('Infix function missing identifier');
      }
      name = {
        type: 'Identifier',
        name: identifierToken.text,
        loc: {
          start: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine,
          },
          end: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
          },
        },
      };
    } else {
      // For regular functions: fun functionName
      const identifierToken = ctx.IDENTIFIER();
      if (!identifierToken) {
        throw new Error('Function missing identifier');
      }
      name = {
        type: 'Identifier',
        name: identifierToken.text,
        loc: {
          start: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine,
          },
          end: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
          },
        },
      };
    }

    const paramList = ctx.parameterList();
    const parameters = paramList
      ? this.visit(paramList)
      : { type: 'ParameterList', parameters: [] };

    // Return type is the last type in the array for infix functions, or the only type for regular functions
    const types = ctx.type();
    const returnType =
      isInfix && types.length > 1
        ? this.visit(types[1])
        : !isInfix && types.length > 0
          ? this.visit(types[0])
          : null;

    const body = this.visit(ctx.block());

    return {
      type: 'FunctionDeclaration',
      isInfix,
      receiverType,
      name,
      annotations,
      parameters: parameters.parameters,
      returnType,
      body: body.body || [],
      loc: this.getLocationInfo(ctx),
    };
  }

  visitGetterDeclaration(ctx: GetterDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const body = this.visit(ctx.block());

    // Handle return type if specified
    const returnType = ctx.type() ? this.visit(ctx.type()!) : undefined;

    return {
      type: 'GetterDeclaration',
      name,
      annotations,
      returnType,
      body: body.body || [],
      loc: this.getLocationInfo(ctx),
    };
  }

  visitMethodDeclaration(ctx: MethodDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const isPrivate = ctx.PRIVATE() !== undefined;
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };

    const paramList = ctx.parameterList();
    const parameters = paramList
      ? this.visit(paramList)
      : { type: 'ParameterList', parameters: [] };

    const typeCtx = ctx.type();
    const returnType = typeCtx ? this.visit(typeCtx) : null;

    const body = this.visit(ctx.block());

    return {
      type: 'MethodDeclaration',
      name,
      annotations,
      isPrivate,
      parameters: parameters.parameters,
      returnType,
      body: body.body || [],
      loc: this.getLocationInfo(ctx),
    };
  }

  visitRepeatedDeclaration(ctx: RepeatedDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const identifierToken = ctx.IDENTIFIER();
    const name = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };
    const typeRef = this.visit(ctx.type());
    const mappingBlock = ctx.mappingBlock();
    const mapping = mappingBlock ? this.visit(mappingBlock) : undefined;
    const expressionCtx = ctx.expression();
    const defaultValue = expressionCtx ? this.visit(expressionCtx) : undefined;

    return {
      type: 'RepeatedDeclaration',
      name,
      annotations,
      typeRef,
      mapping,
      defaultValue,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitMixinDeclaration(ctx: MixinDeclarationContext): ASTNode {
    const annotations = ctx.annotation().map((ann) => this.visit(ann));
    const identifierToken = ctx.IDENTIFIER();
    const mixinName = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };

    return {
      type: 'MixinDeclaration',
      mixinName,
      annotations,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitMappingBlock(ctx: MappingBlockContext): ASTNode {
    const entries = ctx.mappingEntry().map((entry) => this.visit(entry));

    return {
      type: 'MappingBlock',
      entries,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitMappingEntry(ctx: MappingEntryContext): ASTNode {
    const fromToken = ctx.IDENTIFIER(0);
    const toToken = ctx.IDENTIFIER(1);
    const from = {
      type: 'Identifier',
      name: fromToken.text,
      loc: {
        start: {
          line: fromToken.symbol.line,
          column: fromToken.symbol.charPositionInLine,
        },
        end: {
          line: fromToken.symbol.line,
          column: fromToken.symbol.charPositionInLine + fromToken.text.length,
        },
      },
    };
    const to = {
      type: 'Identifier',
      name: toToken.text,
      loc: {
        start: {
          line: toToken.symbol.line,
          column: toToken.symbol.charPositionInLine,
        },
        end: {
          line: toToken.symbol.line,
          column: toToken.symbol.charPositionInLine + toToken.text.length,
        },
      },
    };

    return {
      type: 'MappingEntry',
      from,
      to,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitParameterList(ctx: ParameterListContext): ASTNode {
    const parameters = ctx.parameter().map((param) => this.visit(param));

    return {
      type: 'ParameterList',
      parameters,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitParameter(ctx: ParameterContext): ASTNode {
    const identifierToken = ctx.IDENTIFIER();

    let name: ASTNode;
    if (ctx.THIS() !== undefined) {
      // this.property のパラメータの場合、MemberAccessExpressionとして扱う
      name = {
        type: 'MemberAccessExpression',
        object: {
          type: 'ThisExpression',
          loc: {
            start: {
              line: ctx.THIS()!.symbol.line,
              column: ctx.THIS()!.symbol.charPositionInLine,
            },
            end: {
              line: ctx.THIS()!.symbol.line,
              column: ctx.THIS()!.symbol.charPositionInLine + 4, // 'this'.length
            },
          },
        },
        property: {
          type: 'Identifier',
          name: identifierToken.text,
          loc: {
            start: {
              line: identifierToken.symbol.line,
              column: identifierToken.symbol.charPositionInLine,
            },
            end: {
              line: identifierToken.symbol.line,
              column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
            },
          },
        },
        computed: false,
        loc: this.getLocationInfo(ctx),
      };
    } else {
      // 通常のパラメータの場合
      name = {
        type: 'Identifier',
        name: identifierToken.text,
        loc: {
          start: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine,
          },
          end: {
            line: identifierToken.symbol.line,
            column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
          },
        },
      };
    }

    const typeCtx = ctx.type();
    const typeRef = typeCtx ? this.visit(typeCtx) : undefined;

    return {
      type: 'Parameter',
      name,
      typeRef,
      loc: this.getLocationInfo(ctx),
    };
  }

  // Helper function to create CallExpression nodes consistently
  private createCallExpression(
    callee: ASTNode,
    args: ASTNode[],
    _lambdaBody?: ASTNode[],
    loc?: ASTLocation
  ): ASTNode {
    return {
      type: 'CallExpression',
      callee,
      arguments: args,
      loc,
    };
  }

  visitCallExpression(ctx: CallExpressionContext): ASTNode {
    const identifierToken = ctx.IDENTIFIER();
    const callee = {
      type: 'Identifier',
      name: identifierToken.text,
      loc: {
        start: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine,
        },
        end: {
          line: identifierToken.symbol.line,
          column: identifierToken.symbol.charPositionInLine + identifierToken.text.length,
        },
      },
    };

    // Get regular arguments
    const argList = ctx.argumentList();
    const args = argList ? this.visit(argList).arguments : [];

    // Check for trailing lambda block
    const block = ctx.block();
    if (block) {
      // Convert block to lambda expression and add as last argument
      const blockResult = this.visit(block);
      const lambdaExpression = {
        type: 'LambdaExpression',
        parameters: [],
        body: blockResult.body, // Block already has body as array
        loc: this.getLocationInfo(block),
      };
      args.push(lambdaExpression);
    }

    return {
      type: 'CallExpression',
      callee,
      arguments: args,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitArgumentList(ctx: ArgumentListContext): ASTNode {
    const args = ctx.expression().map((expr) => this.visit(expr));

    return {
      type: 'ArgumentList',
      arguments: args,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitExpressionStatement(ctx: ExpressionStatementContext): ASTNode {
    const expression = this.visit(ctx.expression());
    return {
      type: 'ExpressionStatement',
      expression,
      loc: this.getLocationInfo(ctx),
    };
  }

  // Expression visitors
  visitPrimaryExpr(ctx: PrimaryExprContext): ASTNode {
    return this.visit(ctx.primary());
  }

  visitMemberAccessExpr(ctx: MemberAccessExprContext): ASTNode {
    const object = this.visit(ctx.expression());
    const property = {
      type: 'Identifier',
      name: ctx.IDENTIFIER().text,
      loc: {
        start: {
          line: ctx.IDENTIFIER().symbol.line,
          column: ctx.IDENTIFIER().symbol.charPositionInLine,
        },
        end: {
          line: ctx.IDENTIFIER().symbol.line,
          column: ctx.IDENTIFIER().symbol.charPositionInLine + ctx.IDENTIFIER().text.length,
        },
      },
    };

    return {
      type: 'MemberAccessExpression',
      object,
      property,
      computed: false, // obj.prop の形式なので computed は false
      loc: this.getLocationInfo(ctx),
    };
  }

  visitFuncCallExpr(ctx: FuncCallExprContext): ASTNode {
    const callee = this.visit(ctx.expression());
    const argList = ctx.argumentList();
    const args = argList ? this.visit(argList) : { type: 'ArgumentList', arguments: [] };

    return this.createCallExpression(callee, args.arguments, undefined, this.getLocationInfo(ctx));
  }

  visitNonNullAssertExpr(ctx: NonNullAssertExprContext): ASTNode {
    const operand = this.visit(ctx.expression());

    return {
      type: 'NonNullAssertionExpression',
      operand,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitUnaryMinusExpr(ctx: UnaryMinusExprContext): ASTNode {
    const operand = this.visit(ctx.expression());

    return {
      type: 'UnaryExpression',
      operator: '-',
      operand,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitLogicalNotExpr(ctx: LogicalNotExprContext): ASTNode {
    const operand = this.visit(ctx.expression());

    return {
      type: 'UnaryExpression',
      operator: 'not',
      operand,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitTypeCastExpr(ctx: TypeCastExprContext): ASTNode {
    const expression = this.visit(ctx.expression());

    let targetType: string;
    if (ctx.INT_TYPE()) {
      targetType = 'int';
    } else if (ctx.FLOAT_TYPE()) {
      targetType = 'float';
    } else if (ctx.STRING_TYPE()) {
      targetType = 'string';
    } else if (ctx.BOOL_TYPE()) {
      targetType = 'bool';
    } else {
      targetType = 'unknown';
    }

    return {
      type: 'TypeCastExpression',
      targetType,
      expression,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitMulDivModExpr(ctx: MulDivModExprContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    let operator: string;

    if (ctx.MULTIPLY()) {
      operator = '*';
    } else if (ctx.DIVIDE()) {
      operator = '/';
    } else if (ctx.MODULO()) {
      operator = '%';
    } else {
      operator = 'unknown';
    }

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitAddSubExpr(ctx: AddSubExprContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    const operator = ctx.PLUS() ? '+' : '-';

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitRangeExpr(ctx: RangeExprContext): ASTNode {
    const from = this.visit(ctx.expression(0));
    const to = this.visit(ctx.expression(1));
    const isInclusive = ctx.RANGE_INCLUSIVE() !== undefined;
    return {
      type: 'RangeExpression',
      from,
      to,
      inclusive: isInclusive,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitInfixCallExpr(ctx: InfixCallExprContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    const functionName = ctx.IDENTIFIER().text;

    return {
      type: 'InfixCall',
      functionName,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitRelationalExpr(ctx: RelationalExprContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    let operator: string;

    if (ctx.LESS_THAN()) {
      operator = '<';
    } else if (ctx.GREATER_THAN()) {
      operator = '>';
    } else if (ctx.LESS_EQUALS()) {
      operator = '<=';
    } else if (ctx.GREATER_EQUALS()) {
      operator = '>=';
    } else {
      operator = 'unknown';
    }

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitEqualityExpr(ctx: EqualityExprContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    const operator = ctx.EQUALS() ? '==' : '!=';

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitLogicalAndExpr(ctx: LogicalAndExprContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    const operator = '&&'; // 論理AND演算子は && のみ

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitLogicalOrExpr(ctx: LogicalOrExprContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    const operator = '||'; // 論理OR演算子は || のみ

    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  // Primary expression visitors
  visitLiteralExpr(ctx: LiteralExprContext): ASTNode {
    return this.visit(ctx.literal());
  }

  visitIdentifierExpr(ctx: IdentifierExprContext): ASTNode {
    return {
      type: 'Identifier',
      name: ctx.IDENTIFIER().text,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitThisExpr(ctx: ThisExprContext): ASTNode {
    return {
      type: 'ThisExpression',
      loc: this.getLocationInfo(ctx),
    };
  }

  visitIfExpr(ctx: IfExprContext): ASTNode {
    const condition = this.visit(ctx.expression(0));

    // Get all expressions and blocks
    const expressions = ctx.expression();
    const blocks = ctx.block();

    // Then branch: first expression after condition OR first block
    let thenBranch: any[];
    if (blocks.length > 0 && expressions.length === 1) {
      // Format: if (cond) { block }
      const blockResult = this.visit(blocks[0]);
      thenBranch = blockResult.body;
    } else if (expressions.length > 1) {
      // Format: if (cond) expr
      thenBranch = [
        {
          type: 'ExpressionStatement',
          expression: this.visit(expressions[1]),
          loc: this.getLocationInfo(expressions[1]),
        },
      ];
    } else {
      thenBranch = [];
    }

    // Else branch: optional
    let elseBranch: any[] | undefined = undefined;
    if (ctx.ELSE()) {
      if (blocks.length > 1) {
        // Format: if (cond) { block } else { block }
        const blockResult = this.visit(blocks[1]);
        elseBranch = blockResult.body;
      } else if (blocks.length === 1 && expressions.length > 2) {
        // Format: if (cond) expr else { block }
        const blockResult = this.visit(blocks[0]);
        elseBranch = blockResult.body;
      } else if (expressions.length > 2) {
        // Format: if (cond) expr else expr
        elseBranch = [
          {
            type: 'ExpressionStatement',
            expression: this.visit(expressions[2]),
            loc: this.getLocationInfo(expressions[2]),
          },
        ];
      }
    }

    return {
      type: 'IfExpression',
      condition,
      then: thenBranch,
      else: elseBranch,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitParenExpr(ctx: ParenExprContext): ASTNode {
    return this.visit(ctx.expression());
  }

  visitCallExprPrimary(ctx: CallExprPrimaryContext): ASTNode {
    return this.visit(ctx.callExpression());
  }

  visitLiteral(ctx: LiteralContext): ASTNode {
    const stringLiteralCtx = ctx.stringLiteral();
    if (stringLiteralCtx) {
      return this.visit(stringLiteralCtx);
    } else if (ctx.INTEGER_LITERAL()) {
      return {
        type: 'IntegerLiteral',
        value: parseInt(ctx.INTEGER_LITERAL()!.text),
        raw: ctx.INTEGER_LITERAL()!.text,
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.TRUE()) {
      return {
        type: 'BooleanLiteral',
        value: true,
        raw: 'true',
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.FALSE()) {
      return {
        type: 'BooleanLiteral',
        value: false,
        raw: 'false',
        loc: this.getLocationInfo(ctx),
      };
    }

    return this.defaultResult();
  }

  visitStringLiteral(ctx: StringLiteralContext): ASTNode {
    if (ctx.STRING_LITERAL()) {
      const raw = ctx.STRING_LITERAL()!.text;
      return {
        type: 'StringLiteral',
        value: this.unquote(raw),
        raw,
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.DOUBLE_STRING_LITERAL()) {
      const raw = ctx.DOUBLE_STRING_LITERAL()!.text;
      return {
        type: 'StringLiteral',
        value: this.unquote(raw),
        raw,
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.templateString()) {
      return this.visit(ctx.templateString()!);
    }

    return this.defaultResult();
  }

  visitTemplateString(ctx: TemplateStringContext): ASTNode {
    const parts = ctx.templateStringContent().map((content) => this.visit(content));

    return {
      type: 'TemplateLiteral',
      parts,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitTemplateStringContent(ctx: TemplateStringContentContext): ASTNode {
    if (ctx.TEMPLATE_STRING_PART()) {
      return {
        type: 'TemplateStringPart',
        value: ctx.TEMPLATE_STRING_PART()!.text,
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.TEMPLATE_INTERPOLATION_SIMPLE()) {
      const text = ctx.TEMPLATE_INTERPOLATION_SIMPLE()!.text;
      const identifier = text.substring(1); // Remove the '$' prefix
      return {
        type: 'TemplateInterpolation',
        expression: {
          type: 'Identifier',
          name: identifier,
          loc: this.getLocationInfo(ctx),
        },
        loc: this.getLocationInfo(ctx),
      };
    } else if (ctx.TEMPLATE_INTERPOLATION_START() && ctx.expression()) {
      return {
        type: 'TemplateInterpolation',
        expression: this.visit(ctx.expression()!),
        loc: this.getLocationInfo(ctx),
      };
    }

    return this.defaultResult();
  }

  visitAnnotation(ctx: AnnotationContext): ASTNode {
    const annotationToken = ctx.ANNOTATION();
    const nameText = annotationToken.text.substring(1); // Remove '@' prefix
    const name = {
      type: 'Identifier',
      name: nameText,
      loc: {
        start: {
          line: annotationToken.symbol.line,
          column: annotationToken.symbol.charPositionInLine + 1, // +1 to skip '@'
        },
        end: {
          line: annotationToken.symbol.line,
          column: annotationToken.symbol.charPositionInLine + annotationToken.text.length,
        },
      },
    };
    const arguments_: ASTNode[] = [];

    // Handle arguments list (e.g., @description('text', priority: 1))
    const argumentListCtx = ctx.argumentList();
    if (argumentListCtx) {
      arguments_.push(...this.visitArgumentList(argumentListCtx).arguments);
    }
    // Handle single string literal (e.g., @description 'text')
    else {
      const stringLiteralCtx = ctx.stringLiteral();
      if (stringLiteralCtx) {
        arguments_.push(this.visit(stringLiteralCtx));
      }
    }

    return {
      type: 'Annotation',
      name,
      arguments: arguments_,
      loc: this.getLocationInfo(ctx),
    };
  }

  // List literal visitor
  visitListLiteral(ctx: ListLiteralContext): ASTNode {
    const elements = ctx.expression().map((expr) => this.visit(expr));
    return {
      type: 'ListLiteral',
      elements,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitListLiteralExpr(ctx: ListLiteralExprContext): ASTNode {
    return this.visit(ctx.listLiteral());
  }

  // Lambda expression visitors
  visitLambdaExpression(ctx: LambdaExpressionContext): ASTNode {
    let parameters: ASTNode[] = [];
    if (ctx.lambdaParameters()) {
      const lambdaParams = this.visit(ctx.lambdaParameters()!);
      parameters = lambdaParams.parameters || [];
    }

    let body: ASTNode[] = [];
    if (ctx.lambdaBody()) {
      const lambdaBodyResult = this.visit(ctx.lambdaBody()!);
      if (lambdaBodyResult.type === 'Block') {
        // Multiple statements
        body = lambdaBodyResult.body;
      } else {
        // Single expression - wrap in ExpressionStatement
        body = [
          {
            type: 'ExpressionStatement',
            expression: lambdaBodyResult,
            loc: lambdaBodyResult.loc,
          },
        ];
      }
    }

    return {
      type: 'LambdaExpression',
      parameters,
      body,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitLambdaParameters(ctx: LambdaParametersContext): ASTNode {
    const parameters = ctx.lambdaParameter().map((param) => this.visit(param));
    return {
      type: 'LambdaParameters',
      parameters,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitLambdaParameter(ctx: LambdaParameterContext): ASTNode {
    const name = ctx.IDENTIFIER().text;
    const typeAnnotation = ctx.type() ? this.visit(ctx.type()!) : null;

    return {
      type: 'LambdaParameter',
      name,
      typeAnnotation,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitLambdaBody(ctx: LambdaBodyContext): ASTNode {
    if (ctx.expression()) {
      return this.visit(ctx.expression()!);
    } else {
      const statements = ctx.statement().map((stmt) => this.visit(stmt));
      return {
        type: 'Block',
        body: statements,
        loc: this.getLocationInfo(ctx),
      };
    }
  }

  visitLambdaExpr(ctx: LambdaExprContext): ASTNode {
    return this.visit(ctx.lambdaExpression());
  }

  // Anonymous function visitors
  visitAnonymousFunction(ctx: AnonymousFunctionContext): ASTNode {
    const parameters = ctx.parameterList()
      ? this.visit(ctx.parameterList()!)
      : {
          type: 'ParameterList',
          parameters: [],
          loc: this.getLocationInfo(ctx),
        };

    const returnType = ctx.type() ? this.visit(ctx.type()!) : null;
    const body = this.visit(ctx.block());

    return {
      type: 'AnonymousFunction',
      parameters,
      returnType,
      body,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitAnonFuncExpr(ctx: AnonFuncExprContext): ASTNode {
    return this.visit(ctx.anonymousFunction());
  }

  // Spread expression visitors
  visitSpreadExpression(ctx: SpreadExpressionContext): ASTNode {
    const argument = this.visit(ctx.expression());
    return {
      type: 'SpreadExpression',
      argument,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitSpreadExpr(ctx: SpreadExprContext): ASTNode {
    return this.visit(ctx.spreadExpression());
  }

  // Pipeline expression visitor
  visitPipelineExpr(ctx: PipelineExprContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    return {
      type: 'PipelineExpression',
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  // Bitwise expression visitors
  visitBitwiseAndExpr(ctx: BitwiseAndExprContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    return {
      type: 'BinaryExpression',
      operator: '&',
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitBitwiseXorExpr(ctx: BitwiseXorExprContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    return {
      type: 'BinaryExpression',
      operator: '^',
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitBitwiseOrExpr(ctx: BitwiseOrExprContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    return {
      type: 'BinaryExpression',
      operator: '|',
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  // Shift expression visitor
  visitShiftExpr(ctx: ShiftExprContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    // Determine the operator based on the token
    let operator = '<<';
    if (ctx.text.includes('>>')) {
      operator = '>>';
    }
    return {
      type: 'BinaryExpression',
      operator,
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  // Index access and slice expression visitors
  visitIndexAccessExpr(ctx: IndexAccessExprContext): ASTNode {
    const object = this.visit(ctx.expression(0));
    const index = this.visit(ctx.expression(1));
    return {
      type: 'IndexAccessExpression',
      object,
      index,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitSliceExpr(ctx: SliceExprContext): ASTNode {
    const object = this.visit(ctx.expression(0));
    // Handle optional start and end expressions
    let index;
    if (ctx.expression().length === 3) {
      // start..end format: expression[start..end]
      const from = this.visit(ctx.expression(1));
      const to = this.visit(ctx.expression(2));
      // Calculate location based on start and end expressions
      const fromLoc = (from as ASTNode).loc!;
      const toLoc = (to as ASTNode).loc!;
      index = {
        type: 'RangeExpression',
        from,
        to,
        loc: {
          start: fromLoc.start,
          end: toLoc.end,
        },
      };
    } else if (ctx.expression().length === 2) {
      // Either start.. or ..end format
      const secondExpr = this.visit(ctx.expression(1));
      // This is a simplified implementation - in a real parser you'd need to check which format
      index = secondExpr;
    } else {
      // Just [:] format - full slice
      index = {
        type: 'RangeExpression',
        from: null,
        to: null,
        loc: this.getLocationInfo(ctx),
      };
    }

    return {
      type: 'IndexAccessExpression',
      object,
      index,
      loc: this.getLocationInfo(ctx),
    };
  }

  // Bitwise NOT expression visitor
  visitBitwiseNotExpr(ctx: BitwiseNotExprContext): ASTNode {
    const argument = this.visit(ctx.expression());
    return {
      type: 'UnaryExpression',
      operator: '~',
      argument,
      prefix: true,
      loc: this.getLocationInfo(ctx),
    };
  }

  // Power expression visitor
  visitPowerExpr(ctx: PowerExprContext): ASTNode {
    const left = this.visit(ctx.expression(0));
    const right = this.visit(ctx.expression(1));
    return {
      type: 'BinaryExpression',
      operator: '**',
      left,
      right,
      loc: this.getLocationInfo(ctx),
    };
  }

  visitProgramElement(ctx: ProgramElementContext): ASTNode {
    // ProgramElement is a choice rule, so we visit the actual content
    for (let i = 0; i < ctx.childCount; i++) {
      const child = ctx.getChild(i);
      if (child instanceof RuleNode) {
        return this.visit(child);
      }
    }
    return this.defaultResult();
  }
}

/**
 * Parse Canon source code and return AST
 */
export function parseCanon(source: string, filename: string = '<unknown>'): ASTNode {
  // Create input stream
  const inputStream = CharStreams.fromString(source);

  // Create lexer
  const lexer = new CanonLexer(inputStream);

  // Create token stream
  const tokenStream = new CommonTokenStream(lexer);

  // Create parser
  const parser = new CanonParser(tokenStream);

  // Remove default error listeners
  parser.removeErrorListeners();
  lexer.removeErrorListeners();

  // Add our custom error listener
  const errorListener = new CanonErrorListener(filename);
  parser.addErrorListener(errorListener);
  // Note: lexer uses a different error listener interface, keep default for now

  // Parse the program
  const tree = parser.program();

  // Check for parse errors
  const errorCollection = errorListener.getErrors();
  if (errorCollection.hasErrors()) {
    // Format and display errors
    const errorFormatter = new ErrorFormatter(source, filename);
    const errors = Array.from(errorCollection.getErrors());
    const formattedErrors = errorFormatter.formatErrors(errors);
    console.error(formattedErrors);

    // Throw error to stop processing
    throw new Error(`Parse failed with ${errors.length} error${errors.length > 1 ? 's' : ''}`);
  }

  // Basic error checking - if there are no children, likely a parse error
  if (tree.childCount === 0 && source.trim().length > 0) {
    throw new Error(`Failed to parse Canon file: ${filename}`);
  }

  // Build AST
  const astBuilder = new ASTBuilder();
  return astBuilder.visit(tree);
}

/**
 * Parse Canon file and return AST
 */
export function parseCanonFile(filePath: string): ASTNode {
  const source = fs.readFileSync(filePath, 'utf-8');
  return parseCanon(source, filePath);
}

/**
 * Parse Canon source and convert to YAML
 */
export function parseCanonToYaml(source: string, filename: string = '<unknown>'): string {
  const ast = parseCanon(source, filename);
  return yaml.dump(ast, {
    indent: 2,
    lineWidth: -1,
    sortKeys: false,
  });
}

/**
 * Parse Canon file and convert to YAML
 */
export function parseCanonFileToYaml(filePath: string): string {
  const ast = parseCanonFile(filePath);
  return yaml.dump(ast, {
    indent: 2,
    lineWidth: -1,
    sortKeys: false,
  });
}

/**
 * Parse Canon file and write AST to YAML file
 */
export function parseCanonFileToYamlFile(
  inputFilePath: string,
  outputFilePath: string = 'ast.yml'
): void {
  const yamlContent = parseCanonFileToYaml(inputFilePath);
  fs.writeFileSync(outputFilePath, yamlContent, 'utf-8');
  console.log(`✅ AST written to ${outputFilePath}`);
}

/**
 * Parse Canon source and write AST to YAML file
 */
export function parseCanonToYamlFile(
  source: string,
  outputFilePath: string = 'ast.yml',
  filename: string = '<unknown>'
): void {
  const yamlContent = parseCanonToYaml(source, filename);
  fs.writeFileSync(outputFilePath, yamlContent, 'utf-8');
  console.log(`✅ AST written to ${outputFilePath}`);
}

// Main execution when this file is run directly
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log('Usage: npx tsx src/parser.ts <input-file> [output-file]');
    console.log('');
    console.log('Examples:');
    console.log('  npx tsx src/parser.ts definition/schema.canon');
    console.log('  npx tsx src/parser.ts input.canon output.yaml');
    process.exit(1);
  }

  const inputFile = args[0];
  const outputFile = args[1] || 'ast.yaml';

  if (!fs.existsSync(inputFile)) {
    console.error(`❌ Error: Input file "${inputFile}" does not exist.`);
    process.exit(1);
  }

  try {
    parseCanonFileToYamlFile(inputFile, outputFile);
  } catch (error) {
    console.error(`❌ Error parsing file: ${error}`);
    process.exit(1);
  }
}
